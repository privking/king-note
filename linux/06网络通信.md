# 网络通信

## OSI模型

![image-20200907151517109](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/image-20200907151517109-1599462917-f837c3.png)

![img](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/v2-696eaee5fc25975cd8dfe9015cfc22a3_720w-1599463139-a332e6.jpeg)

#### 物理层

物理层是参考模型的最底层，作用是实现不同计算机节点之间的**比特流**透明传送

#### 数据链路层

主要功能是：通过各种控制协议，将有差错的物理信道**变为无差错的、能可靠传输数据帧的数据链路**。在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法

#### 网络层

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议(ARP)。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。（**选择下一跳，封装mac地址**）

#### 传输层

向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：**TCP/IP中的TCP协议和UDP协议**。

#### 会话层

向两个实体的表示层**提供建立和使用连接的方法**。将不同实体之间的表示层 的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。 用户可以按照**半双工、单工和全双工**的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。

#### 表示层

对来自应用层的**命令和数据进行解释**，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如**编码、数据格式转换和加密解密**等。

#### 应用层

**直接向用户提供服务**，完成用户希望在网络上完成的各种工作。



### centos shell

#### 查看端口监听

![image-20200907154127948](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/image-20200907154127948-1599464488-bd5ef4.png)

#### 查看路由表

![image-20200907154359149](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/image-20200907154359149-1599464639-b7dd38.png)

**目标ip地址&Genmask  == Destination**   -->成功匹配 下一条走该Gateway

匹配顺序策略

- 路由策略匹配。若路由器上有路由策略，首先执行路由策略，若无路由策略，则查询路由表。
- 最长子网掩码匹配。即当在路由表中有多条 到达某个IP地址的路由时，优先选择子网掩码最长的路由。
- 管理距离最小匹配。若执行最长子网掩码匹配后，路由表中 仍有多条到达某个IP地址的路由，优先选择管理距离（AD）最小的。
- 负载均衡。若执行管理距离最小匹配后，路由表中仍有多条达到某个IP地址的路由，则 在剩余的多条链路上执行负载均衡。注意：这里的负载均衡可能是等价的，也可能不是等价的，具体要看使用的路由协议。

#### 查看mac地址对应表

![image-20200907155122496](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/image-20200907155122496-1599465082-8f8d62.png)

通过广播的方式，获取mac地址 然后缓存

PC1发送的请求广播包同时被其他主机收到，然后PC3和PC4收到之后（发现不是问自己）则丢弃。**而PC2收到之后，根据请求包里面的信息（有自己的IP地址），判断是给自己的，所以不会做丢弃动作，而是返回ARP回应包**

大部分的广播包，它们有一个共同特征：**二层封装时目的MAC是全f（ffff.ffff.ffff）或三层封装时目的IP是全1（255.255.255.255）**。可以这样更方便的记住：目的地址最大的，就是广播。



## TCP三次握手，四次挥手

![img](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/v2-e8aaab48ff996e5cd8a5b39dc450bd6a_720w-1599466023-469320.jpeg)

### 三次握手

- 第一次握手：客户端发送网络包，服务端收到了。这样**服务端**就能得出结论：**客户端的发送能力、服务端的接收能力是正常的**。
- 第二次握手：服务端发包，客户端收到了。这样**客户端**就能得出结论：**服务端的接收、发送能力，客户端的接收、发送能力是正常的**。
- 第三次握手：客户端发包，服务端收到了。这样**服务端**就能得出结论：**客户端的接收、发送能力，服务端的发送、接收能力**是正常的。

### 四次挥手

- 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。
- 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 
- 服务端发起自己的FIN段，ACK=K+1, Seq=L 
- 客户端确认。ACK=L+1

### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，**仅仅表示对方不再发送数据了但是还能接收数据**，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。