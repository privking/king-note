# 组件

## EventLoop

**事件循环对象 eventloop**

eventloop本质是一个单线程执行器

它的继承关系如下

- 继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法
- 继承自 netty 自己的 OrderedEventExecutor
  - 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop
  - 提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup

**实现循环组 eventloopgroup**

EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）

- 继承自 netty 自己的 EventExecutorGroup最终还是继承自ScheduledExecutorService
- 实现了 Iterable 接口提供遍历 EventLoop 的能力
- 另有 next 方法获取集合中下一个 EventLoop

### 处理普通以及定时任务

就是ScheduledExecutorService

```java
EventLoopGroup group = new NioEventLoopGroup(2);

/*io.netty.channel.nio.NioEventLoop@4fca772d
io.netty.channel.nio.NioEventLoop@9807454
io.netty.channel.nio.NioEventLoop@4fca772d
io.netty.channel.nio.NioEventLoop@9807454*/
System.out.println(group.next());
System.out.println(group.next());
System.out.println(group.next());
System.out.println(group.next());

group.next().submit(()->{
    try {
        Thread.sleep(1000L);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("submit thread");
});

System.out.println("main thread");
```

### 处理IO任务

#### 同一个pipeline上的handler在同一个group

![img](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/20210421103251-1635178921-5fabc3.png)

**server**

```java
public class MyServer {
    public static void main(String[] args) {
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                ByteBuf buf = (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));

                            }
                        });
                    }
                })
                .bind(8080);
    }
}
```

**client**

```java
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        Channel channel = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                .connect(new InetSocketAddress("localhost", 8080))
                .sync()
                .channel();
        System.out.println(channel);
        // 此处打断点调试，调用 channel.writeAndFlush(...);
        System.in.read();
    }
}
```

#### 同一个pipeline上的handler在不同group

![img](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/20210421103607-1635178909-6fbc26.png)

**server**

```java
public static void main(String[] args) throws InterruptedException {
   
    EventLoopGroup bossGroup = new NioEventLoopGroup();
    EventLoopGroup workerGroup = new NioEventLoopGroup();  //cpu核心数*2
    //创建独立的group处理
    DefaultEventLoopGroup defaultEventLoopGroup = new DefaultEventLoopGroup();

    //是服务端的一个启动辅助类，通过给他设置一系列参数来绑定端口启动服务
    ServerBootstrap serverBootstrap = new ServerBootstrap();
    serverBootstrap.group(bossGroup, workerGroup)
            //设置使用NioServerSocketChannel作为服务器通道的实现
            .channel(NioServerSocketChannel.class)
            .option(ChannelOption.SO_BACKLOG, 128) //设置线程队列中等待连接的个数
            .childOption(ChannelOption.SO_KEEPALIVE, true)//保持活动连接状态
            .childHandler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception {
                    ChannelPipeline pipeline = nioSocketChannel.pipeline();
                    pipeline.addLast(new ChannelInboundHandlerAdapter(){
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                            System.out.println(Thread.currentThread().getName()+buf.toString(StandardCharsets.UTF_8));
                            ctx.fireChannelRead(msg);
                        }
                    });
                  //指定不同的group
                    pipeline.addLast(defaultEventLoopGroup,new ChannelInboundHandlerAdapter(){
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                       System.out.println(Thread.currentThread().getName()+buf.toString(StandardCharsets.UTF_8));
                        }
                    });
                }
            });

    ChannelFuture future = serverBootstrap.bind(9090).sync();
    future.channel().closeFuture().sync();
  
		defaultEventLoopGroup.shutdownGracefully();
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
```

**切换group实现原理**

io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()

```java
static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
    //下一个handler的eventloop
    EventExecutor executor = next.executor();
    //当前handler和下一个handler是否在同一个eventloop
    if (executor.inEventLoop()) {
        //直接调用
        next.invokeChannelRead(m);
    } else {
        //交给下一个eventloop
        executor.execute(new Runnable() {
            @Override
            public void run() {
                next.invokeChannelRead(m);
            }
        });
    }
}
```

