# 组件

## EventLoop

**事件循环对象 eventloop**

eventloop本质是一个单线程执行器

它的继承关系如下

- 继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法
- 继承自 netty 自己的 OrderedEventExecutor
  - 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop
  - 提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup

**实现循环组 eventloopgroup**

EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）

- 继承自 netty 自己的 EventExecutorGroup最终还是继承自ScheduledExecutorService
- 实现了 Iterable 接口提供遍历 EventLoop 的能力
- 另有 next 方法获取集合中下一个 EventLoop

### 处理普通以及定时任务

就是ScheduledExecutorService

```java
EventLoopGroup group = new NioEventLoopGroup(2);

/*io.netty.channel.nio.NioEventLoop@4fca772d
io.netty.channel.nio.NioEventLoop@9807454
io.netty.channel.nio.NioEventLoop@4fca772d
io.netty.channel.nio.NioEventLoop@9807454*/
System.out.println(group.next());
System.out.println(group.next());
System.out.println(group.next());
System.out.println(group.next());

group.next().submit(()->{
    try {
        Thread.sleep(1000L);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("submit thread");
});

System.out.println("main thread");
```

### 处理IO任务

#### 同一个pipeline上的handler在同一个group

![img](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/20210421103251-1635178921-5fabc3.png)

**server**

```java
public class MyServer {
    public static void main(String[] args) {
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                ByteBuf buf = (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));

                            }
                        });
                    }
                })
                .bind(8080);
    }
}
```

**client**

```java
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        Channel channel = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                .connect(new InetSocketAddress("localhost", 8080))
                .sync()
                .channel();
        System.out.println(channel);
        // 此处打断点调试，调用 channel.writeAndFlush(...);
        System.in.read();
    }
}
```

#### 同一个pipeline上的handler在不同group

![img](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/20210421103607-1635178909-6fbc26.png)

**server**

```java
public static void main(String[] args) throws InterruptedException {
   
    EventLoopGroup bossGroup = new NioEventLoopGroup();
    EventLoopGroup workerGroup = new NioEventLoopGroup();  //cpu核心数*2
    //创建独立的group处理
    DefaultEventLoopGroup defaultEventLoopGroup = new DefaultEventLoopGroup();

    //是服务端的一个启动辅助类，通过给他设置一系列参数来绑定端口启动服务
    ServerBootstrap serverBootstrap = new ServerBootstrap();
    serverBootstrap.group(bossGroup, workerGroup)
            //设置使用NioServerSocketChannel作为服务器通道的实现
            .channel(NioServerSocketChannel.class)
            .option(ChannelOption.SO_BACKLOG, 128) //设置线程队列中等待连接的个数
            .childOption(ChannelOption.SO_KEEPALIVE, true)//保持活动连接状态
            .childHandler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception {
                    ChannelPipeline pipeline = nioSocketChannel.pipeline();
                    pipeline.addLast(new ChannelInboundHandlerAdapter(){
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                            System.out.println(Thread.currentThread().getName()+buf.toString(StandardCharsets.UTF_8));
                            ctx.fireChannelRead(msg);
                        }
                    });
                  //指定不同的group
                    pipeline.addLast(defaultEventLoopGroup,new ChannelInboundHandlerAdapter(){
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                       System.out.println(Thread.currentThread().getName()+buf.toString(StandardCharsets.UTF_8));
                        }
                    });
                }
            });

    ChannelFuture future = serverBootstrap.bind(9090).sync();
    future.channel().closeFuture().sync();
  
		defaultEventLoopGroup.shutdownGracefully();
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
```

**切换group实现原理**

io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()

```java
static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
    //下一个handler的eventloop
    EventExecutor executor = next.executor();
    //当前handler和下一个handler是否在同一个eventloop
    if (executor.inEventLoop()) {
        //直接调用
        next.invokeChannelRead(m);
    } else {
        //交给下一个eventloop
        executor.execute(new Runnable() {
            @Override
            public void run() {
                next.invokeChannelRead(m);
            }
        });
    }
}
```



## Channel

- 连接到网络套接字或能够进行读、写、连接和绑定等I/O操作的组件。

- 提供的功能

  - 通道的当前状态(例如，它是打开的吗?它是连接吗?) 
  - 通道的配置参数(例如接收缓冲区大小) 
  - 通道支持的I/O操作(例如读、写、连接和绑定) 
  - ChannelPipeline处理与通道相关的所有I/O事件和请求

- 所有的I/O操作都是异步的

  - 这意味着任何I/O调用将立即返回，而不保证请求的I/O操作在调用结束时已经完成。
  - 相反，会返回一个ChannelFuture实例，该实例将在请求的I/O操作成功、失败或取消时通知。

- 有继承关系

  - 比如 一个被ServerSocketChannel接受的SocketChannel，将在parent()上返回ServerSocketChannel作为SocketChannel的parent。

- 释放资源

  - 调用close()或close(ChannelPromise)来释放所有资源，一旦你完成了Channel。这确保了所有资源都以适当的方式释放

  
```java
  		//返回全局唯一id
      ChannelId id();
      //返回组册的EventLoop
      EventLoop eventLoop();
      //返回parent或null
      Channel parent();
      //返回config
      ChannelConfig config();
      //判断是否open(active之后)
      boolean isOpen();
      //判断是否注册到EventLoop
      boolean isRegistered();
      //判断是否连接建立完成
      boolean isActive();
  
      ChannelMetadata metadata();
      //获取localAddresss或null
      SocketAddress localAddress();
  		//返回remoteAddress或null
      SocketAddress remoteAddress();
      //获取closeFuture
      ChannelFuture closeFuture();
      //判断是否可写
      boolean isWritable();
      //如果可写,获取最多可以写多少字节,直到isWriteable返回false
      long bytesBeforeUnwritable();
      //获取至少缓存区还要刷出的字节数才可写
      long bytesBeforeWritable();
  
    	//localAddress()
  		//remoteAddress()
  		//closeForcibly()
  		//register(EventLoop, ChannelPromise)
  		//deregister(ChannelPromise)
  		//voidPromise()
      Unsafe unsafe();
  		//获取pipeline
      ChannelPipeline pipeline();
      //获取ByteBufAllocator
      ByteBufAllocator alloc();
      @Override
      Channel read();
      @Override
      Channel flush();
  
  //继承ChannelOutboundInvoker借口 
  //连接,断开连接,注册,绑定,读写数据等等
  
  //继承AttributeMap
  //线程安全的Map 
  
  //继承Comparable
```



### EmbeddedChannel

EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可

```java
public class TestEmbeddedChannel {
    public static void main(String[] args) {
        ChannelInboundHandlerAdapter h1 = new ChannelInboundHandlerAdapter() {
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                System.out.println("1");
                super.channelRead(ctx, msg);
            }
        };

        ChannelInboundHandlerAdapter h2 = new ChannelInboundHandlerAdapter() {
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                System.out.println("2");
                super.channelRead(ctx, msg);
            }
        };

        ChannelOutboundHandlerAdapter h3 = new ChannelOutboundHandlerAdapter() {
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                System.out.println("3");
                super.write(ctx, msg, promise);
            }
        };

        ChannelOutboundHandlerAdapter h4 = new ChannelOutboundHandlerAdapter() {
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                System.out.println("4");
                super.write(ctx, msg, promise);
            }
        };

        // 用于测试Handler的Channel
        EmbeddedChannel channel = new EmbeddedChannel(h1, h2, h3, h4);
        
        // 执行Inbound操作 
        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes("hello".getBytes(StandardCharsets.UTF_8)));
        // 执行Outbound操作
        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes("hello".getBytes(StandardCharsets.UTF_8)));
    }
}
```



## ChannelFuture

### 阻塞

```java
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        ChannelFuture channelFuture = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程
            	// NIO线程：NioEventLoop 中的线程
                .connect(new InetSocketAddress("localhost", 8080));
        
        // 该方法用于等待连接真正建立
        channelFuture.sync();
        
      	//这里获取channel一定要sync
        //获取客户端-服务器之间的Channel对象
      	//主线程去执行
        Channel channel = channelFuture.channel();
        channel.writeAndFlush("hello world");
    }
}
```



### 回调

```java
public class MyClient {
    public static void main(String[] args) throws IOException, InterruptedException {
        ChannelFuture channelFuture = new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程
                // NIO线程：NioEventLoop 中的线程
                .connect(new InetSocketAddress("localhost", 8080));
        
				// 当connect方法执行完毕后，也就是连接真正建立后
        // 会在NIO线程中调用operationComplete方法
        // 回调,所以就不用sync
        channelFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture channelFuture) throws Exception {
              	//nio线程去执行
                Channel channel = channelFuture.channel();
                channel.writeAndFlush("hello world");
            }
        });
    }
}
```

### 处理关闭

```java
public class ReadClient {
    public static void main(String[] args) throws InterruptedException {
        // 创建EventLoopGroup，使用完毕后关闭
        NioEventLoopGroup group = new NioEventLoopGroup();
        
        ChannelFuture channelFuture = new Bootstrap()
                .group(group)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        socketChannel.pipeline().addLast(new StringEncoder());
                    }
                })
                .connect(new InetSocketAddress("localhost", 8080));
        //阻塞
        channelFuture.sync();

        Channel channel = channelFuture.channel();
        Scanner scanner = new Scanner(System.in);

        // 创建一个线程用于输入并向服务器发送
        new Thread(()->{
            while (true) {
                String msg = scanner.next();
                if ("q".equals(msg)) {
                    // 关闭操作是异步的，在NIO线程中执行
                    channel.close();
                    break;
                }
                channel.writeAndFlush(msg);
            }
        }, "inputThread").start();

        // 获得closeFuture对象
        ChannelFuture closeFuture = channel.closeFuture();
        System.out.println("waiting close...");
        
        // 同步等待NIO线程执行完close操作
      	 //只要没有调用channel.close()主线程会一直阻塞在这里
        closeFuture.sync();
        
        // 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的
        System.out.println("关闭之后执行一些额外操作...");
        
        // 关闭EventLoopGroup
        group.shutdownGracefully();
    }
}
```

### closeFuture回调

```java
closeFuture.addListener(new ChannelFutureListener() {
    @Override
    public void operationComplete(ChannelFuture channelFuture) throws Exception {
        // 等待channel关闭后才执行的操作
        System.out.println("关闭之后执行一些额外操作...");
        // 关闭EventLoopGroup
        group.shutdownGracefully();
    }
});
```



### 关系

| 功能/名称       | jdk Future                     | netty Future 继承自jdk Future                                | Promise  继承自netty Future                 |
| --------------- | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------- |
| cancel          | 取消任务                       |                                                              |                                             |
| isCanceled      | 任务是否取消                   |                                                              |                                             |
| isDone          | 任务是否完成，不能区分成功失败 |                                                              |                                             |
| get             | 获取任务结果，阻塞等待         |                                                              |                                             |
| getNow          | -                              | 获取任务结果，非阻塞，还未产生结果时返回 null                |                                             |
| await           | -                              | 等待任务结束，如果任务失败，**不会抛异常(不是打断异常,是异步逻辑中的异常)**，而是通过 isSuccess 判断 |                                             |
| sync            | -                              | 等待任务结束，如果任务失败，抛出异常(reThrow异步逻辑中的异常) |                                             |
| isSuccess       | -                              | 判断任务是否成功                                             |                                             |
| cause           | -                              | 获取失败信息，非阻塞，如果没有失败，返回null                 |                                             |
| addLinstener    | -                              | 添加回调，异步接收结果                                       |                                             |
| removeListeners | -                              | 删除回调                                                     |                                             |
| setSuccess      | -                              | -                                                            | 设置成功结果,设置失败抛异常(DefaultPromise) |
| setFailure      | -                              | -                                                            | 设置失败结果,设置失败抛异常(DefaultPromise) |
| trySuccess      | -                              | -                                                            | 设置成功结果,返回是否设置成功               |
| tryFailure      | -                              | -                                                            | 设置失败结果,返回是否设置成功               |

#### jdk Future

```java
public class JdkFuture {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadFactory factory = new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "JdkFuture");
            }
        };
        // 创建线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10), factory);

        // 获得Future对象
        Future<Integer> future = executor.submit(new Callable<Integer>() {

            @Override
            public Integer call() throws Exception {
                TimeUnit.SECONDS.sleep(1);
                return 50;
            }
        });
        // 通过阻塞的方式，获得运行结果
        System.out.println(future.get());
    }
}
```

#### Netty Future

```java
public class NettyFuture {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        NioEventLoopGroup group = new NioEventLoopGroup();

        // 获得 EventLoop 对象
        EventLoop eventLoop = group.next();
        Future<Integer> future = eventLoop.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                return 50;
            }
        });

        // 主线程中获取结果
        System.out.println(Thread.currentThread().getName() + " 获取结果");
        System.out.println("getNow " + future.getNow());
        System.out.println("get " + future.get());

        // NIO线程中异步获取结果
        future.addListener(new GenericFutureListener<Future<? super Integer>>() {
            @Override
            public void operationComplete(Future<? super Integer> future) throws Exception {
                System.out.println(Thread.currentThread().getName() + " 获取结果");
                System.out.println("getNow " + future.getNow());
            }
        });
    }
}
```

#### Netty Promise

```java
public class NettyPromise {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建EventLoop
        NioEventLoopGroup group = new NioEventLoopGroup();
        EventLoop eventLoop = group.next();

        // 创建Promise对象，用于存放结果
        DefaultPromise<Integer> promise = new DefaultPromise<>(eventLoop);

        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 自定义线程向Promise中存放结果
            promise.setSuccess(50);
        }).start();

        // 主线程从Promise中获取结果
        System.out.println(Thread.currentThread().getName() + " " + promise.get());
    }
}
```

## Handler&Pipeline

```java
public class PipeLineServer {
    public static void main(String[] args) {
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        // 在socketChannel的pipeline中添加handler
                        // pipeline中handler是带有head与tail节点的双向链表，的实际结构为
    				 						// head <-> handler1 <-> ... <-> handler4 <->tail
                        // Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法
                        // 入站时，handler是从head向后调用的
                        socketChannel.pipeline().addLast("handler1" ,new ChannelInboundHandlerAdapter() {
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                System.out.println(Thread.currentThread().getName() + " Inbound handler 1");
                                // 父类该方法内部会调用fireChannelRead
                                // 将数据传递给下一个handler
                                super.channelRead(ctx, msg);
                            }
                        });
                        socketChannel.pipeline().addLast("handler2", new ChannelInboundHandlerAdapter() {
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                System.out.println(Thread.currentThread().getName() + " Inbound handler 2");
                                // 执行write操作，使得Outbound的方法能够得到调用
         												socketChannel.writeAndFlush(ctx.alloc().buffer().
                                      writeBytes("Server...".getBytes(StandardCharsets.UTF_8)));
                                super.channelRead(ctx, msg);
                            }
                        });
                        // Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法
                        // 出站时，handler的调用是从tail向前调用的
                        socketChannel.pipeline().addLast("handler3" ,new ChannelOutboundHandlerAdapter(){
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                                System.out.println(Thread.currentThread().getName() + " Outbound handler 1");
                                super.write(ctx, msg, promise);
                            }
                        });
                        socketChannel.pipeline().addLast("handler4" ,new ChannelOutboundHandlerAdapter(){
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                                System.out.println(Thread.currentThread().getName() + " Outbound handler 2");
                                super.write(ctx, msg, promise);
                            }
                        });
                    }
                })
                .bind(8080);
    }
}
```

如果给handler起了名字 ,可以调用pipeline的**addAfter、addBefore等方法更灵活地向pipeline中添加handler**

handler需要放入通道的pipeline中，才能根据放入顺序来使用handler

- pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler
  - 要通过ctx.fireChannelRead(msg)等方法，**将当前handler的处理结果传递给下一个handler**
- 当有**入站**（Inbound）操作时，会从**head开始向后**调用handler，直到handler不是处理Inbound操作为止
- 当有**出站**（Outbound）操作时，会从**tail开始向前**调用handler，直到handler不是处理Outbound操作为止

**socketChannel.writeAndFlush**()

当handler中调用该方法进行写操作时，会触发Outbound操作，**此时是从tail向前寻找**

**ctx.writeAndFlush**()

当handler中调用该方法进行写操作时，会触发Outbound操作，**此时是从当前handler向前寻找OutboundHandler**

### LoggingHandler

当添加`.addLast("logging", new LoggingHandler(LogLevel.INFO))`这行代码时

Netty就会以给定的日志级别打印出`LoggingHandler`中的日志。

可以对入站\出站事件进行日志记录，从而方便我们进行问题排查。

假如现在添加这行代码访问http://127.0.0.1:8007/Action?name=1234510

```java
19:10:52.089 [nioEventLoopGroup-2-6] INFO io.netty.handler.logging.LoggingHandler - [id: 0x4a9db561, L:/127.0.0.1:8007 - R:/127.0.0.1:53151] REGISTERED
19:10:52.089 [nioEventLoopGroup-2-6] INFO io.netty.handler.logging.LoggingHandler - [id: 0x4a9db561, L:/127.0.0.1:8007 - R:/127.0.0.1:53151] ACTIVE
19:10:52.090 [nioEventLoopGroup-2-6] DEBUG com.bihang.seaya.server.handler.SeayaHandler - io.netty.handler.codec.http.DefaultHttpRequest
19:10:52.090 [nioEventLoopGroup-2-6] DEBUG com.bihang.seaya.server.handler.SeayaHandler - uri/Action?name=1234510
19:10:52.090 [nioEventLoopGroup-2-6] INFO io.netty.handler.logging.LoggingHandler - [id: 0x4a9db561, L:/127.0.0.1:8007 - R:/127.0.0.1:53151] CLOSE
19:10:52.090 [nioEventLoopGroup-2-6] INFO io.netty.handler.logging.LoggingHandler - [id: 0x4a9db561, L:/127.0.0.1:8007 ! R:/127.0.0.1:53151] INACTIVE
19:10:52.090 [nioEventLoopGroup-2-6] INFO io.netty.handler.logging.LoggingHandler - [id: 0x4a9db561, L:/127.0.0.1:8007 ! R:/127.0.0.1:53151] UNREGISTERED
```

如果没有这行代码的打印信息

```java
19:15:02.292 [nioEventLoopGroup-2-2] DEBUG com.bihang.seaya.server.handler.SeayaHandler - io.netty.handler.codec.http.DefaultHttpRequest
19:15:02.292 [nioEventLoopGroup-2-2] DEBUG com.bihang.seaya.server.handler.SeayaHandler - uri/Action?name=1234510
```
